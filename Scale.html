<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Scale of the Universe 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffcc;
            pointer-events: none;
            text-shadow: 0 0 5px #00ffcc;
        }
        h1 { margin: 0; font-size: 1.5rem; text-transform: uppercase; letter-spacing: 2px; }
        #scale-readout { font-size: 1.2rem; margin-top: 10px; color: white; }
        #instructions {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            pointer-events: none;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.3; } 50% { opacity: 0.8; } 100% { opacity: 0.3; } }
        
        /* Loading overlay */
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            color: white; z-index: 999; transition: opacity 1s;
        }
    </style>
</head>
<body>

    <div id="loading">Initializing Universe...</div>
    
    <div id="ui">
        <h1>Cosmic Scale</h1>
        <div id="scale-readout">Scale: 10⁻¹⁵ meters</div>
        <div id="object-name" style="font-size: 2rem; font-weight: bold; margin-top: 10px; color: #fff;">Proton</div>
    </div>

    <div id="instructions">SCROLL TO ZOOM IN/OUT</div>
    
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // --- Configuration ---
        // We use a logarithmic scale concept.
        // currentLogScale represents the exponent of meters we are viewing.
        // -15 = Proton, 0 = 1 meter, 21 = Galaxy
        let state = {
            currentLogScale: -15, 
            targetLogScale: -15,
            scrollSpeed: 0.005
        };

        const objectsData = [
            { name: "Proton", scale: -15, type: 'proton', color: 0xff0055 },
            { name: "Hydrogen Atom", scale: -10, type: 'atom', color: 0x00aaff },
            { name: "DNA Strand", scale: -8.5, type: 'dna', color: 0xaa00ff },
            { name: "Beach Ball", scale: -0.5, type: 'ball', color: 0xffaa00 }, // ~30cm
            { name: "Earth", scale: 7.1, type: 'earth', color: 0x2233ff },
            { name: "The Sun", scale: 9.1, type: 'sun', color: 0xffdd00 },
            { name: "Solar System", scale: 13, type: 'solar', color: 0xffffff },
            { name: "Milky Way Galaxy", scale: 20.8, type: 'galaxy', color: 0x8888ff }
        ];

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02); // Distant fade

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20; 
        camera.position.y = 5;
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 2, 100);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        // --- Object Generators ---
        const models = {}; // Store references to meshes

        function createProton() {
            const group = new THREE.Group();
            // Quarks
            const geom = new THREE.SphereGeometry(1, 32, 32);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0xff0055, emissive: 0x550022, roughness: 0.4 
            });
            
            const p1 = new THREE.Mesh(geom, mat);
            p1.position.set(0.5, 0, 0);
            const p2 = new THREE.Mesh(geom, mat);
            p2.position.set(-0.5, 0.5, 0);
            const p3 = new THREE.Mesh(geom, mat);
            p3.position.set(-0.2, -0.6, 0.3);
            
            group.add(p1, p2, p3);
            
            // Energy glow
            const glowGeom = new THREE.SphereGeometry(2.5, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0055, transparent: true, opacity: 0.1, wireframe: true 
            });
            group.add(new THREE.Mesh(glowGeom, glowMat));

            return group;
        }

        function createAtom() {
            const group = new THREE.Group();
            // Nucleus
            const nGeom = new THREE.SphereGeometry(1, 16, 16);
            const nMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            group.add(new THREE.Mesh(nGeom, nMat));

            // Electron trails (Torus)
            const rings = [
                { r: 4, rot: [1, 1, 0] },
                { r: 4.5, rot: [0, 1, 1] },
                { r: 5, rot: [1, 0, 1] }
            ];

            rings.forEach(d => {
                const ringGeom = new THREE.TorusGeometry(d.r, 0.05, 16, 100);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.6 });
                const mesh = new THREE.Mesh(ringGeom, ringMat);
                mesh.rotation.set(...d.rot);
                group.add(mesh);
                
                // Add electron particle
                const eGeom = new THREE.SphereGeometry(0.2, 8, 8);
                const eMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const electron = new THREE.Mesh(eGeom, eMat);
                // Animate electron in update loop later
                electron.userData = { radius: d.r, speed: Math.random() * 0.05 + 0.02, angle: Math.random() * Math.PI * 2 };
                mesh.add(electron); 
            });

            return group;
        }

        function createDNA() {
            const group = new THREE.Group();
            const sphere = new THREE.SphereGeometry(0.3, 8, 8);
            const mat1 = new THREE.MeshStandardMaterial({ color: 0xff00ff });
            const mat2 = new THREE.MeshStandardMaterial({ color: 0x00ffff });
            
            for(let i = -10; i < 10; i++) {
                const angle = i * 0.5;
                const y = i * 0.8;
                
                const b1 = new THREE.Mesh(sphere, mat1);
                b1.position.set(Math.cos(angle) * 2, y, Math.sin(angle) * 2);
                
                const b2 = new THREE.Mesh(sphere, mat2);
                b2.position.set(Math.cos(angle + Math.PI) * 2, y, Math.sin(angle + Math.PI) * 2);

                // Connector
                const barGeom = new THREE.CylinderGeometry(0.1, 0.1, 4, 4);
                barGeom.rotateZ(Math.PI / 2);
                const barMat = new THREE.MeshBasicMaterial({ color: 0xcccccc });
                const bar = new THREE.Mesh(barGeom, barMat);
                bar.position.set(0, y, 0);
                bar.rotation.y = -angle;

                group.add(b1, b2, bar);
            }
            group.rotation.z = Math.PI / 4;
            return group;
        }

        function createBeachBall() {
            const geom = new THREE.SphereGeometry(1, 32, 32);
            // Simple striped texture using canvas
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white'; ctx.fillRect(0,0,128,128);
            const colors = ['red', 'blue', 'yellow', 'green', 'orange', 'white'];
            for(let i=0; i<6; i++){
                ctx.fillStyle = colors[i];
                ctx.fillRect(i*21, 0, 21, 128);
            }
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.2 });
            return new THREE.Mesh(geom, mat);
        }

        function createEarth() {
            const group = new THREE.Group();
            const geom = new THREE.SphereGeometry(1, 64, 64);
            const mat = new THREE.MeshPhongMaterial({ 
                color: 0x1122aa, emissive: 0x000022, specular: 0x111111, shininess: 10 
            });
            const earth = new THREE.Mesh(geom, mat);
            group.add(earth);
            
            // Atmosphere
            const atmoGeom = new THREE.SphereGeometry(1.05, 64, 64);
            const atmoMat = new THREE.MeshBasicMaterial({ 
                color: 0x4488ff, transparent: true, opacity: 0.2, side: THREE.BackSide 
            });
            group.add(new THREE.Mesh(atmoGeom, atmoMat));
            return group;
        }

        function createSun() {
            const geom = new THREE.SphereGeometry(1, 64, 64);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            const mesh = new THREE.Mesh(geom, mat);
            
            // Corona glow
            const glowGeom = new THREE.SphereGeometry(1.2, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.3 });
            mesh.add(new THREE.Mesh(glowGeom, glowMat));
            
            return mesh;
        }

        function createSolarSystem() {
            const group = new THREE.Group();
            // Sun (small in center)
            const sun = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 16),
                new THREE.MeshBasicMaterial({color: 0xffff00})
            );
            group.add(sun);
            
            // Orbit rings
            const rings = [1, 1.5, 2, 3, 5];
            rings.forEach(r => {
                const ringGeom = new THREE.RingGeometry(r, r+0.05, 64);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x444444, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(ringGeom, ringMat);
                mesh.rotation.x = Math.PI / 2;
                group.add(mesh);
            });
            return group;
        }

        function createGalaxy() {
            const group = new THREE.Group();
            const particlesGeom = new THREE.BufferGeometry();
            const particleCount = 4000;
            const posArray = new Float32Array(particleCount * 3);
            const colorsArray = new Float32Array(particleCount * 3);
            
            for(let i=0; i<particleCount; i++) {
                const i3 = i * 3;
                const radius = Math.random() * 5 + 0.5;
                const spinAngle = radius * 2; // Spiral math
                const branchAngle = (i % 3) * ((Math.PI * 2) / 3);
                
                const randomX = (Math.random() - 0.5) * (Math.random() * 2);
                const randomY = (Math.random() - 0.5) * (Math.random() * 0.5); // Flattened disk
                const randomZ = (Math.random() - 0.5) * (Math.random() * 2);

                const x = Math.cos(spinAngle + branchAngle) * radius + randomX;
                const y = randomY; 
                const z = Math.sin(spinAngle + branchAngle) * radius + randomZ;

                posArray[i3] = x;
                posArray[i3+1] = y;
                posArray[i3+2] = z;
                
                // Color (Purple/Blue center, White/Yellow outer)
                const mixedColor = new THREE.Color();
                mixedColor.setHSL(0.6 + Math.random() * 0.2, 0.8, 0.5);
                colorsArray[i3] = mixedColor.r;
                colorsArray[i3+1] = mixedColor.g;
                colorsArray[i3+2] = mixedColor.b;
            }
            
            particlesGeom.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            particlesGeom.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));
            
            const mat = new THREE.PointsMaterial({ size: 0.05, vertexColors: true, transparent: true, opacity: 0.8 });
            const points = new THREE.Points(particlesGeom, mat);
            group.add(points);
            return group;
        }

        // --- Initialization ---
        function initObjects() {
            objectsData.forEach(obj => {
                let mesh;
                switch(obj.type) {
                    case 'proton': mesh = createProton(); break;
                    case 'atom': mesh = createAtom(); break;
                    case 'dna': mesh = createDNA(); break;
                    case 'ball': mesh = createBeachBall(); break;
                    case 'earth': mesh = createEarth(); break;
                    case 'sun': mesh = createSun(); break;
                    case 'solar': mesh = createSolarSystem(); break;
                    case 'galaxy': mesh = createGalaxy(); break;
                    default: mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({color:'red'}));
                }
                
                // We add a 'baseScale' to the userData to know where it belongs on the number line
                mesh.userData.logScale = obj.scale;
                mesh.userData.baseScale = 1; // Visual size normalized to roughly 1 unit
                mesh.visible = false; // Start hidden
                
                scene.add(mesh);
                models[obj.type] = mesh;
            });

            // Starfield Background
            const starGeom = new THREE.BufferGeometry();
            const starCount = 2000;
            const starPos = new Float32Array(starCount * 3);
            for(let i=0; i<starCount*3; i++) {
                starPos[i] = (Math.random() - 0.5) * 200;
            }
            starGeom.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.1});
            const stars = new THREE.Points(starGeom, starMat);
            scene.add(stars);

            document.getElementById('loading').style.opacity = 0;
            setTimeout(() => document.getElementById('loading').remove(), 1000);
        }

        initObjects();

        // --- Event Listeners ---
        window.addEventListener('wheel', (e) => {
            state.targetLogScale += e.deltaY * state.scrollSpeed;
            // Clamp scale
            state.targetLogScale = Math.max(-16, Math.min(25, state.targetLogScale));
        });
        
        // Touch support
        let touchStartY = 0;
        window.addEventListener('touchstart', e => touchStartY = e.touches[0].clientY);
        window.addEventListener('touchmove', e => {
            const dy = e.touches[0].clientY - touchStartY;
            state.targetLogScale -= dy * 0.05;
            state.targetLogScale = Math.max(-16, Math.min(25, state.targetLogScale));
            touchStartY = e.touches[0].clientY;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            // Smooth zoom interpolation
            state.currentLogScale += (state.targetLogScale - state.currentLogScale) * 0.1;

            // UI Updates
            const power = Math.floor(state.currentLogScale);
            document.getElementById('scale-readout').innerText = `10${toSuperscript(power)} meters`;
            
            // Find closest object name
            let closestObj = objectsData.reduce((prev, curr) => {
                return (Math.abs(curr.scale - state.currentLogScale) < Math.abs(prev.scale - state.currentLogScale) ? curr : prev);
            });
            document.getElementById('object-name').innerText = closestObj.name;
            document.getElementById('object-name').style.color = '#' + closestObj.color.toString(16);

            // Render Logic:
            // The trick: We keep the camera fixed. We scale the OBJECTS relative to the current scale.
            // If Object Scale is 10^7 and Current Scale is 10^7, Object is drawn at size 1.
            // If Object Scale is 10^7 and Current Scale is 10^8, Object is drawn at size 0.1.
            
            scene.children.forEach(child => {
                // Background stars stay constant
                if (child.type === 'Points' && !child.userData.logScale) return;
                if (child.type === 'AmbientLight' || child.type === 'PointLight') return;

                if (child.userData.logScale !== undefined) {
                    const scaleDiff = child.userData.logScale - state.currentLogScale;
                    
                    // We only render objects within +/- 4 orders of magnitude to avoid float errors
                    if (Math.abs(scaleDiff) < 5) {
                        child.visible = true;
                        
                        // Calculate visual scale: 10^(objScale - currentScale)
                        const visualScale = Math.pow(10, scaleDiff);
                        child.scale.setScalar(visualScale);
                        
                        // Fade out if too small or too big
                        let opacity = 1;
                        if (scaleDiff < -2) opacity = Math.max(0, (3 + scaleDiff)); // Fade out as it gets tiny
                        if (scaleDiff > 1) opacity = Math.max(0, (2 - scaleDiff)); // Fade out as camera goes "inside"
                        
                        // Apply opacity recursively to materials
                        child.traverse(c => {
                            if (c.material) {
                                c.material.transparent = true;
                                c.material.opacity = opacity;
                                c.material.needsUpdate = true;
                            }
                        });

                        // Specific animations
                        if (child.userData.logScale === -10) { // Atom animation
                            child.children.forEach((ring, idx) => {
                                if (idx > 0) { // Skip nucleus
                                    ring.rotation.z += 0.05;
                                    // Move electron
                                    if(ring.children[0]) {
                                        const el = ring.children[0];
                                        el.userData.angle += el.userData.speed;
                                        el.position.x = Math.cos(el.userData.angle) * el.userData.radius;
                                        el.position.y = Math.sin(el.userData.angle) * el.userData.radius;
                                    }
                                }
                            });
                        }
                        else if (child.userData.logScale === -8.5) { // DNA rotate
                            child.rotation.y += 0.01;
                        }
                        else if (child.userData.logScale === 7.1) { // Earth rotate
                            child.children[0].rotation.y += 0.005;
                        }
                        else if (child.userData.logScale === 20.8) { // Galaxy rotate
                            child.rotation.y += 0.001;
                        }

                    } else {
                        child.visible = false;
                    }
                }
            });

            renderer.render(scene, camera);
        }

        // Helper for UI
        function toSuperscript(num) {
            const map = {
                '-': '⁻', '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴', 
                '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹'
            };
            return num.toString().split('').map(c => map[c] || c).join('');
        }

        animate();
    </script>
</body>
</html>
      
